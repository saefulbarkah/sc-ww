
"use strict";var _a,_b,_c;function toVector2R(t){return t?t.X&&t.Y?t:{X:t.X??0,Y:t.Y??0}:{X:0,Y:0}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNormalVector2D=exports.isClockwise=exports.rotateVertex=exports.degreesToRadians=exports.isInSimpleShape=exports.isInRangeConfig=exports.Vector3Op=exports.toVectorInfo=exports.toVector3R=exports.RectOp=exports.Vector2Op=exports.toVector2R=void 0,exports.toVector2R=toVector2R;class Vector2Op{static New(t,e){return{X:t,Y:e}}static CacheNew(t,e){let r=this.ve.get(e),a=(r||(r=new Map,this.ve.set(e,r)),r.get(t));return a||(a=this.New(t,e),r.set(t,a)),a}static Clone(t){return this.New(t.X,t.Y)}static Assign(t,e){t.X=e.X,t.Y=e.Y}static Round(t){return this.New(Math.round(t.X),Math.round(t.Y))}static RoundS(t){return t.X=Math.round(t.X),t.Y=Math.round(t.Y),t}static Format(t){return t?void 0===t.X||void 0===t.Y?Vector2Op.New(t.X??0,t.Y??0):t:Vector2Op.Zero}static Str(t){return`(${t.X}, ${t.Y})`}static Add(t,e){return this.New(t.X+e.X,t.Y+e.Y)}static Sub(t,e){return this.New(t.X-e.X,t.Y-e.Y)}static Len(t){return Math.sqrt(t.X*t.X+t.Y*t.Y)}static Mul(t,e){return this.New(t.X*e,t.Y*e)}static Div(t,e){return this.New(t.X/e,t.Y/e)}static SquareDistance(t,e){var r=t.X-e.X,t=t.Y-e.Y;return r*r+t*t}static Distance(t,e){var r=t.X-e.X,t=t.Y-e.Y;return Math.sqrt(r*r+t*t)}static Equal(t,e){return Math.abs(t.X-e.X)<1e-4&&Math.abs(t.Y-e.Y)<1e-4}static Intersect(t,e,r,a){var n=e.X-t.X,e=e.Y-t.Y,o=a.X-r.X,a=a.Y-r.Y,s=-o*e+n*a;return 0!=s&&(e=(-e*(t.X-r.X)+n*(t.Y-r.Y))/s,n=(o*(t.Y-r.Y)-a*(t.X-r.X))/s,0<=e)&&e<=1&&0<=n&&n<=1}}exports.Vector2Op=Vector2Op,(_a=Vector2Op).One=_a.New(1,1),Vector2Op.Zero=_a.New(0,0),Vector2Op.ve=new Map;class RectOp{static New(t,e){return{Min:{X:t.X-e.X/2,Y:t.Y-e.Y/2},Max:{X:t.X+e.X/2,Y:t.Y+e.Y/2}}}static NewByMin(t,e){return{Min:t,Max:Vector2Op.Add(t,e)}}static NewByPos(t,e){if(t.X<e.X&&t.Y<e.Y)return{Min:t,Max:e};let r=t.X,a=e.X,n=(t.X>e.X&&(r=e.X,a=t.X),t.Y),o=e.Y;return t.Y>e.Y&&(n=e.Y,o=t.Y),{Min:Vector2Op.New(r,n),Max:Vector2Op.New(a,o)}}static RoundS(t){return Vector2Op.RoundS(t.Min),Vector2Op.RoundS(t.Max),t}static Equal(t,e){return Vector2Op.Equal(t.Min,e.Min)&&Vector2Op.Equal(t.Max,e.Max)}static Clone(t){return{Min:Vector2Op.Clone(t.Min),Max:Vector2Op.Clone(t.Max)}}static Str(t){return`中心: ${Vector2Op.Str(this.GetCenter(t))} 大小: `+Vector2Op.Str(this.GetSize(t))}static GetCenter(t){return Vector2Op.New((t.Min.X+t.Max.X)/2,(t.Min.Y+t.Max.Y)/2)}static GetSize(t){return Vector2Op.New(t.Max.X-t.Min.X,t.Max.Y-t.Min.Y)}static ToDrawPoints(t){var e=t.Min,t=t.Max;return[e,{X:e.X,Y:t.Y},t,{X:t.X,Y:e.Y},e]}static Contains(t,e){return t.Min.X<=e.X&&e.X<t.Max.X&&t.Min.Y<=e.Y&&e.Y<t.Max.Y}static IntersectLine(t,e,r){var a=t.Min,t=t.Max,n=a,o={X:t.X,Y:a.Y},s=t,a={X:a.X,Y:t.Y};return Vector2Op.Intersect(e,r,n,o)||Vector2Op.Intersect(e,r,o,s)||Vector2Op.Intersect(e,r,s,a)||Vector2Op.Intersect(e,r,a,n)}static IntersectOrIncludeLine(t,e,r){var a,n,o;return!(!RectOp.Contains(t,e)&&!RectOp.Contains(t,r))||(o=t.Min,n={X:(t=t.Max).X,Y:(a=o).Y},t={X:o.X,Y:(o=t).Y},Vector2Op.Intersect(e,r,a,n))||Vector2Op.Intersect(e,r,n,o)||Vector2Op.Intersect(e,r,o,t)||Vector2Op.Intersect(e,r,t,a)}}function toVector3R(t){return t?t.X&&t.Y&&t.Z?t:{X:t.X??0,Y:t.Y??0,Z:t.Z??0}:{X:0,Y:0,Z:0}}function toVectorInfo(t){return t?t.X&&t.Y&&t.Z?t:{X:t.X??0,Y:t.Y??0,Z:t.Z??0}:{X:0,Y:0,Z:0}}exports.RectOp=RectOp,(_b=RectOp).One=_b.New(Vector2Op.Zero,Vector2Op.One),RectOp.Zero=_b.New(Vector2Op.Zero,Vector2Op.Zero),exports.toVector3R=toVector3R,exports.toVectorInfo=toVectorInfo;class Vector3Op{static New(t,e,r){return{X:t,Y:e,Z:r}}static Format(t){return t?void 0===t.X||void 0===t.Y||void 0===t.Z?Vector3Op.New(t.X??0,t.Y??0,t.Z??0):t:Vector3Op.Zero}static Add(t,e){return{X:(t.X??0)+(e.X??0),Y:(t.Y??0)+(e.Y??0),Z:(t.Z??0)+(e.Z??0)}}static Sub(t,e){return{X:(t.X??0)-(e.X??0),Y:(t.Y??0)-(e.Y??0),Z:(t.Z??0)-(e.Z??0)}}static Cross(t,e){return{X:t.Y*e.Z-t.Z*e.Y,Y:t.Z*e.X-t.X*e.Z,Z:t.X*e.Y-t.Y*e.X}}static Dot(t,e){return t.X*e.X+t.Y*e.Y+t.Z*e.Z}static Mul(t,e){return{X:t.X*e,Y:t.Y*e,Z:t.Z*e}}static Div(t,e){return{X:t.X/e,Y:t.Y/e,Z:t.Z/e}}static Magnitude(t){return Math.sqrt(t.X**2+t.Y**2+t.Z**2)}static Distance(t,e){return Math.sqrt((t.X-e.X)**2+(t.Y-e.Y)**2+(t.Z-e.Z)**2)}static PowDistance(t,e){return(t.X-e.X)**2+(t.Y-e.Y)**2+(t.Z-e.Z)**2}static Normalize(t){var e=this.Magnitude(t),r=this.Magnitude({X:t.X,Y:t.Y,Z:0}),a=t.Z,n=r/e,o=t.Y/r;return{X:t.X/r*n,Y:o*n,Z:a/e}}static Abs(t){return{X:Math.abs(t.X),Y:Math.abs(t.Y),Z:Math.abs(t.Z)}}static IsZero(t){return!t.X&&!t.Y&&!t.Z}static TransformByRotation(t,e){var r=t=>t*Math.PI/180,a=r(t.X),n=r(t.Y),r=r(t.Z),t=Math.cos(a),a=Math.sin(a),o=Math.cos(n),n=Math.sin(n),s=Math.cos(r),r=Math.sin(r),{X:e,Y:c,Z:i}=e;return{X:o*s*e+(o*r*a-n*t)*c+(o*r*t+n*a)*i,Y:n*s*e+(n*r*a+o*t)*c+(n*r*t-o*a)*i,Z:-r*e+s*a*c+s*t*i}}}function isInRangeConfig(t,e){var r=e.Center,e=e.Radius;return Vector3Op.PowDistance({X:t.X??0,Y:t.Y??0,Z:t.Z??0},{X:r.X??0,Y:r.Y??0,Z:r.Z??0})<=e*e}function isInSphereRange(t,e,r){var a=e.Radius;return Vector3Op.PowDistance({X:t.X??0,Y:t.Y??0,Z:t.Z??0},{X:(r.X??0)+(e.Center.X??0),Y:(r.Y??0)+(e.Center.Y??0),Z:(r.Z??0)+(e.Center.Z??0)})<=a*a}function isInBoxRange(t,e,r){var a=(r.X??0)+(e.Center.X??0)-(e.Size.X??0)/2,n=(r.X??0)+(e.Center.X??0)+(e.Size.X??0)/2,o=(r.Y??0)+(e.Center.Y??0)-(e.Size.Y??0)/2,s=(r.Y??0)+(e.Center.Y??0)+(e.Size.Y??0)/2,c=(r.Z??0)+(e.Center.Z??0)-(e.Size.Z??0)/2,r=(r.Z??0)+(e.Center.Z??0)+(e.Size.Z??0)/2;return(t.X??0)>a&&(t.X??0)<n&&(t.Y??0)>o&&(t.Y??0)<s&&(t.Z??0)>c&&(t.Z??0)<r}function isInCylinderRange(t,e,r){var r=Math.sqrt(((t.X??0)-((r.X??0)+(e.Center.X??0)))**2+((t.Y??0)-((r.Y??0)+(e.Center.Y??0)))**2),a=(t.Z??0)+(e.Center.Z??0)-e.Height/2,n=(t.Z??0)+(e.Center.Z??0)+e.Height/2;return r<e.Radius&&(t.Z??0)>a&&(t.Z??0)<n}function isInHollowSphereRange(t,e,r){var a=e.Radius,n=e.InnerRadius,t=Vector3Op.PowDistance({X:t.X??0,Y:t.Y??0,Z:t.Z??0},{X:(r.X??0)+(e.Center.X??0),Y:(r.Y??0)+(e.Center.Y??0),Z:(r.Z??0)+(e.Center.Z??0)});return t<=a*a&&n*n<=t}function isInHollowCylinderRange(t,e,r){var a=Math.sqrt(((t.X??0)-((r.X??0)+(e.Center.X??0)))**2+((t.Y??0)-((r.Y??0)+(e.Center.Y??0)))**2),n=(r.Z??0)+(e.Center.Z??0)-e.Height/2,r=(r.Z??0)+(e.Center.Z??0)+e.Height/2;return a<=e.Radius&&a>=e.InnerRadius&&(t.Z??0)>n&&(t.Z??0)<r}function isInSimpleShape(t,e,r){let a=!1;var n=r??{X:0,Y:0,Z:0};switch(e.Type){case"Box":a=isInBoxRange(t,e,n);break;case"Sphere":a=isInSphereRange(t,e,n);break;case"Cylinder":a=isInCylinderRange(t,e,n);break;case"HollowSphere":a=isInHollowSphereRange(t,e,n);break;case"HollowCylinder":a=isInHollowCylinderRange(t,e,n)}return a}function degreesToRadians(t){return t*Math.PI/180}function rotateVertex(t,e){var t=toVector3R(t),e=toVector3R(e),r=Math.cos(degreesToRadians(e.X)),a=Math.sin(degreesToRadians(e.X)),n=Math.cos(degreesToRadians(e.Y)),o=Math.sin(degreesToRadians(e.Y)),s=Math.cos(degreesToRadians(e.Z)),e=Math.sin(degreesToRadians(e.Z)),c=t.Y*r-t.Z*a,a=t.Y*a+t.Z*r,r=t.X*n+a*o;return{X:r*s-c*e,Y:r*e+c*s,Z:-t.X*o+a*n}}function isClockwise(e){let r=0;var a=e.length;for(let t=0;t<e.length;t++){var n=e[t]?.X??0,o=e[(t+1)%a]?.X??0,s=e[t]?.Y??0,c=e[(t+1)%a]?.Y??0;r+=(o-n)*(c+s)}return r<0}function getNormalVector2D(t,e){return e?{X:t.Y,Y:-t.X,Z:0}:{X:-t.Y,Y:t.X,Z:0}}exports.Vector3Op=Vector3Op,(_c=Vector3Op).One=_c.New(1,1,1),Vector3Op.Zero=_c.New(0,0,0),exports.isInRangeConfig=isInRangeConfig,exports.isInSimpleShape=isInSimpleShape,exports.degreesToRadians=degreesToRadians,exports.rotateVertex=rotateVertex,exports.isClockwise=isClockwise,exports.getNormalVector2D=getNormalVector2D;
//# sourceMappingURL=Geometry.js.map