
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SkillBehaviorCondition=void 0;const Log_1=require("../../../../../../../Core/Common/Log"),GameplayTagUtils_1=require("../../../../../../../Core/Utils/GameplayTagUtils"),Vector_1=require("../../../../../../../Core/Utils/Math/Vector"),MathUtils_1=require("../../../../../../../Core/Utils/MathUtils"),CharacterAttributeTypes_1=require("../../Abilities/CharacterAttributeTypes"),SkillBehaviorMisc_1=require("./SkillBehaviorMisc"),SkillConditionParser_1=require("./SkillConditionParser");class SkillBehaviorCondition{static SatisfyGroup(r,e,i){var a,o=[];for(let t=0;t<r.Num();t++)if(a=this.Satisfy(r.Get(t),i),e)o.push(a);else if(!a)return!1;if(o.length)try{var t=new SkillConditionParser_1.Parser(e).Parse();return new SkillConditionParser_1.ConditionArray(o,t).Evaluate()}catch(t){return t instanceof Error?Log_1.Log.CheckError()&&Log_1.Log.ErrorWithStack("Battle",28,"条件公式解析异常",t,["formula",e],["error",t.message]):Log_1.Log.CheckError()&&Log_1.Log.Error("Battle",28,"条件公式解析异常",["formula",e],["error",t]),!1}return!0}static Satisfy(t,r){switch(t.ConditionType){case 0:return this.uZo(t,r);case 1:return this.cZo(t,r);case 2:return this.mZo(t,r);case 3:return this.dZo(t,r);case 4:return this.CZo(t,r);case 5:return this.gZo(t,r);default:return!1}}static uZo(t,r){let e=!1;return r.SkillComponent.SkillTarget&&(e=!0),t.Reverse?!e:e}static cZo(t,r){let e=!1;var i;return r.SkillComponent.SkillTarget&&(i=r.Entity.GetComponent(1).ActorLocationProxy,r=Vector_1.Vector.Create(r.SkillComponent.GetTargetTransform().GetLocation()),i=t.IgnoreZ?Vector_1.Vector.Dist2D(i,r):Vector_1.Vector.Distance(i,r),e=(0,SkillBehaviorMisc_1.compare)(t.ComparisonLogic,i,t.Value,t.RangeL,t.RangeR)),t.Reverse?!e:e}static mZo(t,r){let e=!1;var i,a,o;return r.SkillComponent.SkillTarget&&(a=(i=r.Entity.GetComponent(1)).ActorLocationProxy,r=Vector_1.Vector.Create(r.SkillComponent.GetTargetTransform().GetLocation()),o=Vector_1.Vector.Create(),r.Subtraction(a,o),t.IgnoreZ&&(o.Z=0),o.Normalize(),r=t.Sign?MathUtils_1.MathUtils.GetAngleByVectorDotWithSign(o,i.ActorForwardProxy):MathUtils_1.MathUtils.GetAngleByVectorDot(o,i.ActorForwardProxy),e=(0,SkillBehaviorMisc_1.compare)(t.ComparisonLogic,r,t.Value,t.RangeL,t.RangeR)),t.Reverse?!e:e}static dZo(t,r){r=r.Entity.GetComponent(203),r=t.AnyTag?r.HasAnyTag(GameplayTagUtils_1.GameplayTagUtils.ConvertFromUeContainer(t.TagToCheck)):r.HasAllTag(GameplayTagUtils_1.GameplayTagUtils.ConvertFromUeContainer(t.TagToCheck));return t.Reverse?!r:r}static CZo(t,r){var r=r.Entity.GetComponent(171),e=r.GetCurrentValue(t.AttributeId1),r=0<t.AttributeId2?r.GetCurrentValue(t.AttributeId2):0,e=(0,SkillBehaviorMisc_1.compare)(t.ComparisonLogic,e,t.Value+r*t.AttributeRate*CharacterAttributeTypes_1.DIVIDED_TEN_THOUSAND,t.RangeL,t.RangeR);return t.Reverse?!e:e}static gZo(t,r){r=r.Entity.GetComponent(176).GetHeightAboveGround(),r=(0,SkillBehaviorMisc_1.compare)(t.ComparisonLogic,r,t.Value,t.RangeL,t.RangeR);return t.Reverse?!r:r}}exports.SkillBehaviorCondition=SkillBehaviorCondition;
//# sourceMappingURL=SkillBehaviorCondition.js.map